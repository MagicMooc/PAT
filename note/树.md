## 1004 Counting Leaves (30 分)

A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.

### Input Specification:

Each input file contains one test case. Each case starts with a line containing 0<*N*<100, the number of nodes in a tree, and *M* (<*N*), the number of non-leaf nodes. Then *M* lines follow, each in the format:

```
ID K ID[1] ID[2] ... ID[K]
```

where `ID` is a two-digit number representing a given non-leaf node, `K` is the number of its children, followed by a sequence of two-digit `ID`'s of its children. For the sake of simplicity, let us fix the root ID to be `01`.

The input ends with *N* being 0. That case must NOT be processed.

### Output Specification:

For each test case, you are supposed to count those family members who have no child **for every seniority level** starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.

The sample case represents a tree with only 2 nodes, where `01` is the root and `02` is its only child. Hence on the root `01` level, there is `0` leaf node; and on the next level, there is `1` leaf node. Then we should output `0 1` in a line.

### Sample Input:

```in
2 1
01 1 02
```

### Sample Output:

```out
0 1
```



### Solution:

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 110;
int h[N], e[N], ne[N], idx = 0;
int max_depth, cnt[N];

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u, int depth)
{
    if(h[u]==-1){
        cnt[depth]++;
        max_depth = max(depth, max_depth);
        return;
    }
    for (int i = h[u]; ~i; i = ne[i]){
        dfs(e[i], depth + 1);
    }
}

int main()
{
    memset(h, -1, sizeof(h));
    int n, m;
    cin >> n >> m;
    while (m--)
    {
        int id, k;
        cin >> id >> k;
        for (int i = 0; i < k; i++)
        {
            int son;
            cin >> son;
            add(id, son);
        }
    }
    dfs(1, 0);
    cout << cnt[0];
    for (int i = 1; i <= max_depth; i++)
    {
        cout << ' ' << cnt[i];
    }
    cout << endl;
    return 0;
}
```





## 1020 Tree Traversals (25 分)

Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input:

```in
7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
```

### Sample Output:

```out
4 1 6 3 5 7 2
```



### Solution:

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;
const int N = 40;
int postorder[N], inorder[N], q[N];
unordered_map<int, int> l, r, pos;
int n;

int build(int il, int ir, int pl, int pr)
{
    int root = postorder[pr];
    int k = pos[root];
    if (il < k)
    {
        l[root] = build(il, k - 1, pl, pl + (k - 1 - il));
    }
    if (ir > k)
    {
        r[root] = build(k + 1, ir, pl + (k - 1 - il) + 1, pr - 1);
    }
    return root;
}

void bfs(int root)
{
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh++];
        if (l.count(t))
        {
            q[++tt] = l[t];
        }
        if (r.count(t))
        {
            q[++tt] = r[t];
        }
    }
    cout << q[0];
    for (int i = 1; i < n; i++)
    {
        cout << ' ' << q[i];
    }
    cout << endl;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> postorder[i];
    }
    for (int i = 0; i < n; i++)
    {
        cin >> inorder[i];
        pos[inorder[i]] = i;
    }
    int root = build(0, n - 1, 0, n - 1);
    bfs(root);
    return 0;
}
```





## 1021 Deepest Root (25 分)

A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called **the deepest root**.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤104) which is the number of nodes, and hence the nodes are numbered from 1 to *N*. Then *N*−1 lines follow, each describes an edge by given the two adjacent nodes' numbers.

### Output Specification:

For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print `Error: K components` where `K` is the number of connected components in the graph.

### Sample Input 1:

```in
5
1 2
1 3
1 4
2 5
```

### Sample Output 1:

```out
3
4
5
```

### Sample Input 2:

```in
5
1 3
1 4
2 5
3 4
```

### Sample Output 2:

```out
Error: 2 components
```



### Solution:

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>

using namespace std;
const int N = 10010, M = N * 2;
int h[N], e[M], ne[M], idx, p[N];

int find(int x){
    if(p[x]!=x){
        p[x] = find(p[x]);
    }
    return p[x];
}

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dfs(int u, int father){
    int depth = 0;
    for (int i = h[u]; ~i; i = ne[i]){
        int j = e[i];
        if(j==father) continue;
        depth = max(depth, dfs(j, u) + 1);
    }
    return depth;
}

int main(){
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    memset(h, -1, sizeof(h));
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        p[i] = i;
    }

    int k = n;
    for (int i = 0; i < n - 1; i++)
    {
        int a, b;
        cin >> a >> b;
        if(find(a)!=find(b)){
            k--;
            p[find(b)] = find(a);
        }
        add(a, b);
        add(b, a);
    }
    if(k > 1){
        printf("Error: %d components", k);
    }else{
        int max_depth = -1;
        vector<int> nodes;
        for (int i = 1; i <= n; i++)
        {
            int depth = dfs(i, -1);
            if(depth>max_depth){
                max_depth = depth;
                nodes.clear();
                nodes.push_back(i);
            }else if(depth == max_depth){
                nodes.push_back(i);
            }
        }

        for (auto v : nodes){
            cout << v << endl;
        }
    }
    return 0;
}
```





## 1043 Is It a Binary Search Tree (25 分)

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

If we swap the left and right subtrees of every node, then the resulting tree is called the **Mirror Image** of a BST.

Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* integer keys are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first print in a line `YES` if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or `NO` if not. Then if the answer is `YES`, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
8 6 5 7 10 8 11
```

### Sample Output 1:

```out
YES
5 7 6 8 11 10 8
```

### Sample Input 2:

```in
7
8 10 11 8 6 7 5
```

### Sample Output 2:

```out
YES
11 8 10 7 5 6 8
```

### Sample Input 3:

```in
7
8 6 8 5 10 9 11
```

### Sample Output 3:

```out
NO
```



### Solution:

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 1010;
int preorder[N], inorder[N], postorder[N];
int cnt = 0, n;

bool build(int il, int ir, int pl, int pr, int type)
{
    if (il > ir)
    {
        return true;
    }

    int root = preorder[pl];
    int k;
    if (type == 0)
    {
        for (k = il; k <= ir; k++)
        {
            if (inorder[k] == root)
            {
                break;
            }
        }
        if (k > ir)
        {
            return false;
        }
    }
    else
    {
        for (k = ir; k >= il; k--)
        {
            if (inorder[k] == root)
            {
                break;
            }
        }
        if (k < il)
        {
            return false;
        }
    }

    bool res = true;
    if (!build(il, k - 1, pl + 1, pl + 1 + (k - 1 - il), type))
    {
        res = false;
    }
    if (!build(k + 1, ir, pl + 1 + (k - 1 - il) + 1, pr, type))
    {
        res = false;
    }

    postorder[cnt++] = root;
    return res;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> preorder[i];
        inorder[i] = preorder[i];
    }
    sort(inorder, inorder + n);
    if (build(0, n - 1, 0, n - 1, 0))
    {
        puts("YES");
        cout << postorder[0];
        for (int i = 1; i < n; i++)
        {
            cout << ' ' << postorder[i];
        }
        cout << endl;
    }
    else
    {
        cnt = 0;
        reverse(inorder, inorder + n);
        if (build(0, n - 1, 0, n - 1, 1))
        {
            puts("YES");
            cout << postorder[0];
            for (int i = 1; i < n; i++)
            {
                cout << ' ' << postorder[i];
            }
            cout << endl;
        }
        else
        {
            puts("NO");
        }
    }
}
```



## 1064 Complete Binary Search Tree (30 分)

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.

Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.

### Output Specification:

For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input:

```in
10
1 2 3 4 5 6 7 8 9 0
```

### Sample Output:

```out
6 3 8 1 5 7 9 0 2 4
```



### Solution:

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010;
int n;
int w[N], tr[N];

void dfs(int u, int &k)
{
    if (u * 2 <= n)
    {
        dfs(u * 2, k);
    }
    tr[u] = w[k++];
    if (u * 2 + 1 <= n)
    {
        dfs(u * 2 + 1, k);
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> w[i];
    }
    sort(w, w + n);
    int k = 0;
    dfs(1, k);
    cout << tr[1];
    for (int i = 2; i <= n; i++)
    {
        cout << ' ' << tr[i];
    }
    cout << endl;
    return 0;
}
```





## 1086 Tree Traversals Again (25 分)

An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.


![img](/Users/zhanghao/Pictures/img/30.jpeg)

Figure 1

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to *N*). Then 2*N* lines follow, each describes a stack operation in the format: "Push X" where X is the index of the node being pushed onto the stack; or "Pop" meaning to pop one node from the stack.

### Output Specification:

For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input:

```in
6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
```

### Sample Output:

```out
3 4 2 6 5 1
```



### Solution:

```cpp
#include <iostream>
#include <stack>

using namespace std;
const int N = 40;
int l[N], r[N];
int n;

void dfs(int u, int root)
{
    if (!u)
    {
        return;
    }
    dfs(l[u], root);
    dfs(r[u], root);
    cout << u;
    if (u != root)
    {
        cout << ' ';
    }
}

int main()
{
    cin >> n;
    int type, last = 0, root;
    stack<int> stk;
    for (int i = 0; i < n * 2; i++)
    {
        string op;
        cin >> op;
        if (op == "Push")
        {
            int x;
            cin >> x;
            if (!last)
            {
                root = x;
            }
            else
            {
                if (type == 0)
                {
                    l[last] = x;
                }
                else
                {
                    r[last] = x;
                }
            }
            last = x;
            stk.push(x);
            type = 0;
        }
        else
        {
            last = stk.top();
            stk.pop();
            type = 1;
        }
    }

    dfs(root, root);
    return 0;
}
```



```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <stack>

using namespace std;
const int N = 40;
int preorder[N], inorder[N], postorder[N], pos[N], l[N], r[N];
int n, cnt = 0;

int build(int il, int ir, int pl, int pr)
{
    int root = preorder[pl];
    int k = pos[root];
    if (k > il)
    {
        l[root] = build(il, k - 1, pl + 1, pl + 1 + (k - 1 - il));
    }
    if (k < ir)
    {
        r[root] = build(k + 1, ir, pl + 1 + (k - 1 - il) + 1, pr);
    }

    return root;
}

void dfs(int u)
{
    if (!u)
    {
        return;
    }
    dfs(l[u]);
    dfs(r[u]);
    postorder[cnt++] = u;
}

int main()
{
    cin >> n;
    stack<int> stk;
    int pi = 0, ii = 0;
    for (int i = 0; i < 2 * n; i++)
    {
        string op;
        cin >> op;
        if (op == "Push")
        {
            int x;
            cin >> x;
            stk.push(x);
            preorder[pi++] = x;
        }
        else
        {
            inorder[ii] = stk.top();
            stk.pop();
            pos[inorder[ii]] = ii;
            ii++;
        }
    }

    int root = build(0, n - 1, 0, n - 1);
    dfs(root);
    cout << postorder[0];
    for (int i = 1; i < n; i++)
    {
        cout << ' ' << postorder[i];
    }
    cout << endl;

    return 0;
}
```





## 1099 Build A Binary Search Tree (30 分)

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.

![figBST.jpg](/Users/zhanghao/Pictures/img/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg)

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤100) which is the total number of nodes in the tree. The next *N* lines each contains the left and the right children of a node in the format `left_index right_index`, provided that the nodes are numbered from 0 to *N*−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally *N* distinct integer keys are given in the last line.

### Output Specification:

For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.

### Sample Input:

```in
9
1 6
2 3
-1 -1
-1 4
5 -1
-1 -1
7 -1
-1 8
-1 -1
73 45 11 58 82 25 67 38 42
```

### Sample Output:

```out
58 25 82 11 38 67 45 73 42
```



### Solution:

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 110;
int n;
int l[N], r[N], a[N], w[N], q[N];

void dfs(int u, int &k)
{
    if (u == -1)
    {
        return;
    }
    dfs(l[u], k);
    w[u] = a[k++];
    dfs(r[u], k);
}

void bfs(int u)
{
    int hh = 0, tt = 0;
    q[0] = u;
    while (hh <= tt)
    {
        int t = q[hh++];
        if (l[t] != -1)
        {
            q[++tt] = l[t];
        }
        if (r[t] != -1)
        {
            q[++tt] = r[t];
        }
    }
    cout << w[q[0]];
    for (int i = 1; i < n; i++)
    {
        cout << ' ' << w[q[i]];
    }
    cout << endl;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> l[i] >> r[i];
    }
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a, a + n);
    int k = 0;
    dfs(0, k);
    bfs(0);
    return 0;
}
```





## 1102 Invert a Binary Tree (25 分)

The following is from Max Howell @twitter:

```
Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off.
```

Now it's your turn to prove that YOU CAN invert a binary tree!

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤10) which is the total number of nodes in the tree -- and hence the nodes are numbered from 0 to *N*−1. Then *N* lines follow, each corresponds to a node from 0 to *N*−1, and gives the indices of the left and right children of the node. If the child does not exist, a `-` will be put at the position. Any pair of children are separated by a space.

### Output Specification:

For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.

### Sample Input:

```in
8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6
```

### Sample Output:

```out
3 7 2 6 4 0 5 1
6 5 7 4 3 2 0 1
```



### Solution:

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 15;
int n;
int l[N], r[N], q[N];
bool has_father[N];
int inorder[N], cnt = 0;

void dfs_reverse(int u)
{
    if (u == -1)
    {
        return;
    }
    dfs_reverse(l[u]);
    dfs_reverse(r[u]);
    swap(l[u], r[u]);
}

void bfs(int u)
{
    int hh = 0, tt = 0;
    q[0] = u;
    while (hh <= tt)
    {
        int t = q[hh++];
        if (l[t] != -1)
        {
            q[++tt] = l[t];
        }
        if (r[t] != -1)
        {
            q[++tt] = r[t];
        }
    }
    cout << q[0];
    for (int i = 1; i < n; i++)
    {
        cout << ' ' << q[i];
    }
    cout << endl;
}

void dfs(int u)
{
    if (u == -1)
    {
        return;
    }
    dfs(l[u]);
    inorder[cnt++] = u;
    dfs(r[u]);
}

int main()
{
    memset(l, -1, sizeof(l));
    memset(r, -1, sizeof(r));

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        char lc, rc;
        cin >> lc >> rc;
        if (lc != '-')
        {
            l[i] = lc - '0';
            has_father[l[i]] = true;
        }
        if (rc != '-')
        {
            r[i] = rc - '0';
            has_father[r[i]] = true;
        }
    }

    int root = 0;

    while (has_father[root])
    {
        root++;
    }
    dfs_reverse(root);
    bfs(root);
    dfs(root);
    cout << inorder[0];
    for (int i = 1; i < n; i++)
    {
        cout << ' ' << inorder[i];
    }
    cout << endl;

    return 0;
}
```

